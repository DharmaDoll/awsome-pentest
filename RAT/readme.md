### attacker.sh

1. It begins by launching into the background the file transfer “daemon.”
2. Here the script waits for an incoming connection from the remote script. The use of the nc command is crucial here because the bash network file descriptor (/dev/tcp) cannot perform a TCP wait.
3. Our file-transfer function also begins by listening, but to the second port number. What it expects to hear from that socket is a filename.
4. Another call to nc—this time to send the file requested in the previous communication. It’s a network cat command, so it’s just a matter of supplying the file as the input to the command, connecting to the third port number.

### RemoteRat.sh
 1. この接続を待機していたLocalRat.shスクリプトのncコマンドに戻されます。 ただし、奇妙に見えるのは、ここに組み込まれているexecコマンドです。 通常、シェルの代わりに別のプログラムを起動するために使用されます。 コマンドが指定されていない場合（この場合のように）、すべてのリダイレクトが確立され、新しいI / O接続で実行が続行されます。 これ以降、スクリプトがstdoutまたはstderrに書き込むときは常に、TCPソケットに書き込まれます。  stdinから読み取ると、ソケットから読み取られます。
2. 出力の最初のビットはプロンプトのような文字列であるため、リモートシステムのユーザーは入力を始めることができます。  -nオプションは改行を省略しているため、プロンプトのように見えます。

3. readステートメントは、TCPソケットを介してユーザーの入力を読み取ります。  -rオプションは、バックスラッシュを通常の文字のように扱うように読み取りに指示します。 バックスラッシュを含む文字列を読み取る間、特別な解釈は行われません。

 4. ユーザーの返信の最初の文字が感嘆符（別名bang）である場合、（設計によると）ユーザーはスクリプトのアップロードを要求しています。

 5. この部分文字列は、インデックス1から文字列の終わりまでの、バンを含まない応答です。  runScript関数を呼び出すときに、2つの別々のステップとしてではなく、インラインでそれを行うことができます。

 6. スクリプトの中心はこの行にあります。 ユーザーは、このスクリプトが読み取るTCPソケットを介して文字列を送信しました。 その文字列に対してevalを実行して、その文字列内のコマンドを実行しています。 攻撃者が文字列、lsを送信した場合、lsコマンドが実行され、その出力が攻撃者に返されます。

 7. スクリプトを実行するように求められると、runScript関数が呼び出され、最初のアクションは、スクリプトの名前を攻撃者のシステム（スクリプトが常駐する場所）に送り返すことです。  stdoutのリダイレクトは、2番目のポート番号を介して接続を確立します。

 8. スリープの目的は、データが他のシステムに到達する時間を与え、そのシステムが反応して応答する時間を与えることです。 極端なネットワーク遅延が発生した場合は、スリープの長さを長くする必要がある場合があります。

 9. もう一方がすべてうまくいった場合、この接続（stdinのリダイレクト）は攻撃者のシステムに接続する必要があり、要求されたスクリプトの内容はstdinから読み取れるはずです。 出力を一時ファイルに保存します。

 10. ファイルができたので、bashで実行できます。 その出力はどこに行きますか？  execステートメントで行ったリダイレクトを覚えていますか？  bash $ TMPFLを呼び出すときに何もリダイレクトしないため、stdoutは引き続きTCPポートに接続されており、攻撃者の画面に出力が表示されます。

