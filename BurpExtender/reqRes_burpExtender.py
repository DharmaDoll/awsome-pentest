from burp import IBurpExtender
from burp import IMessageEditorTabFactory
from burp import IMessageEditorTab
from burp import IParameter
from java.io import PrintWriter
import sys
import traceback
import subprocess
import base64
import array
import ast
import json
import hmac
import hashlib
import codecs
from aeslibrary import AESCipher

class BurpExtender(IBurpExtender, IMessageEditorTabFactory):
    
    def registerExtenderCallbacks(self, callbacks):
        sys.stdout = callbacks.getStdout()
        sys.stderr = callbacks.getStderr()
        # keep a reference to our callbacks object
        self.callbacks = callbacks
        self.stdout = PrintWriter(callbacks.getStdout(), True)
        self.stderr = PrintWriter(callbacks.getStderr(), True)      
        # obtain an extension helpers object
        self.helpers = callbacks.getHelpers()
        # set our extension name
        callbacks.setExtensionName("xxx")
        # register ourselves as a message editor tab factory
        callbacks.registerMessageEditorTabFactory(self)

        return
    
    def createNewInstance(self, controller, editable):
        # create a new instance of our custom editor tab
        return xHelperTab(self, controller, editable)
        
class xHelperTab(IMessageEditorTab):

    def __init__(self, extender, controller, editable):
        self.extender = extender
        # create an instance of Burp's text editor, to display our deserialized data
        self.txtInput = extender.callbacks.createTextEditor()
        self.editable = editable
        self.controller = controller
        self.txtInput.setEditable(editable)
        self.httpHeaders = None
        self.body = None
        self.content = None
        self.key = 'qazwsx*44'
        self.hmac_key = self.key
        self.isRequest = True

        return

    def getTabCaption(self):
        return "xxx Plain Text"
        
    def getUiComponent(self):
        return self.txtInput.getComponent()
    
    def isEnabled(self, content, isRequest):
        return True

    def isModified(self):
        return self.txtInput.isTextModified()

    def getSelectedData(self):
        return self.txtInput.getSelectedText()

    def decodeRequest(self, content):
        res = self.extender.helpers.analyzeResponse(content)
        self.httpHeaders = res.getHeaders() #store headers
        data = content[res.getBodyOffset():]

        body = None
        body = json.loads(data.tostring(), encoding='utf-8')
        encrypted_parameters = json.loads(base64.b64decode(body['encrypted_parameters']), encoding='utf-8')
        iv = encrypted_parameters['iv']

        proc = subprocess.Popen(['python', 'aeslibrary.py', 'dec', self.key, iv, encrypted_parameters['value']],\
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        proc.wait()
        output = proc.stdout.read()
        errors = proc.stderr.read()

        print "output: %s" % (output)
        print "error: %s" % (errors)

        output = json.loads(base64.b64decode(output), encoding='utf-8')
        encrypted_parameters['value'] = output
        body['encrypted_parameters'] = encrypted_parameters

        pretty = json.dumps(body, indent=4, sort_keys=True, ensure_ascii=False, encoding='utf-8') 

        return pretty

    def encodeRequest(self, plain_text):
        body = json.loads(plain_text.tostring(), encoding='utf-8')
        value = body['encrypted_parameters']['value']
        value = json.dumps(value, encoding='utf-8').replace(' ', '')
        iv = body['encrypted_parameters']['iv']
        
        proc = subprocess.Popen(['python', 'aeslibrary.py', 'enc', self.key, iv, base64.b64encode(value)],\
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        proc.wait()
        output = proc.stdout.read()
        errors = proc.stderr.read()

        print "output: %s" % (output)
        print "error: %s" % (errors)

        body['encrypted_parameters']['value'] = output
        message = body['encrypted_parameters']['iv'] + body['encrypted_parameters']['value']
        body['encrypted_parameters']['mac'] = hmac.new(base64.b64decode(self.hmac_key), message, hashlib.sha256).hexdigest()

        body['encrypted_parameters'] = json.dumps(body['encrypted_parameters'], encoding='utf-8')
        body['encrypted_parameters'] = base64.b64encode(body['encrypted_parameters'])

        body = json.dumps(body, encoding='utf-8')
        content = self.extender.helpers.buildHttpMessage(self.httpHeaders, body)
        return content

    def decodeResponse(self, content):
        res = self.extender.helpers.analyzeResponse(content)
        self.httpHeaders = res.getHeaders() #store headers

        if "HTTP/1.1 100 Continue" in self.httpHeaders:
            content = content[res.getBodyOffset():]
            res = self.extender.helpers.analyzeResponse(content)
            self.httpHeaders = res.getHeaders() #store headers again
        data = content[res.getBodyOffset():]
        body = None
        body = json.loads(data.tostring(), encoding='utf-8')
        encrypted_payload = json.loads(base64.b64decode(body['encrypted_payload']), encoding='utf-8')
        iv = encrypted_payload['iv']

        proc = subprocess.Popen(['python', 'aeslibrary.py', 'dec', self.key, iv, encrypted_payload['value']],\
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        proc.wait()
        output = proc.stdout.read()
        errors = proc.stderr.read()

        print "output: %s" % (output)
        print "error: %s" % (errors)

        output = json.loads(base64.b64decode(output), encoding='utf-8')
        encrypted_payload['value'] = output
        body['encrypted_payload'] = encrypted_payload

        pretty = json.dumps(body, indent=4, sort_keys=True, ensure_ascii=False, encoding='utf-8') 

        return pretty
    
    def encodeResponse(self, plain_text):
        body = json.loads(plain_text.tostring(), encoding='utf-8')
        value = body['encrypted_payload']['value']
        value = json.dumps(value, encoding='utf-8').replace(' ', '')
        iv = body['encrypted_payload']['iv']
        
        proc = subprocess.Popen(['python', 'aeslibrary.py', 'enc', self.key, iv, base64.b64encode(value)],\
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        proc.wait()
        output = proc.stdout.read()
        errors = proc.stderr.read()

        print "output: %s" % (output)
        print "error: %s" % (errors)

        body['encrypted_payload']['value'] = output
        message = body['encrypted_payload']['iv'] + body['encrypted_payload']['value']
        body['encrypted_payload']['mac'] = hmac.new(base64.b64decode(self.hmac_key), message, hashlib.sha256).hexdigest()

        body['encrypted_payload'] = json.dumps(body['encrypted_payload'], encoding='utf-8')
        body['encrypted_payload'] = base64.b64encode(body['encrypted_payload'])
        body = json.dumps(body, encoding='utf-8')

        content = self.extender.helpers.buildHttpMessage(self.httpHeaders, body)
        return content

    def setMessage(self, content, isRequest):
        try:
            host = self.controller.getHttpService().getHost()
            self.currentMessage = content
            self.isRequest = isRequest

            if not isRequest:
                pretty = self.decodeResponse(content)
            else:
                pretty = self.decodeRequest(content)

            self.txtInput.setText(pretty.encode('utf-8'))
            self.txtInput.setEditable(True)
        except:
            print traceback.format_exc()

    def getMessage(self):

        try:
            if self.txtInput.isTextModified():
                if not self.isRequest:
                    plain_text = self.txtInput.getText()
                    content = self.encodeResponse(plain_text)
                    return content
                else:
                    plain_text = self.txtInput.getText()
                    content = self.encodeRequest(plain_text)
                    return content
        except:
            print traceback.format_exc()

        return "error"
